(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Subject'), require('@angular/common'), require('rxjs/Subscription')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/Subject', '@angular/common', 'rxjs/Subscription'], factory) :
    (factory((global['ng-in-viewport'] = {}),global.ng.core,global.Subject,global.ng.common,global.Subscription));
}(this, (function (exports,core,Subject,common,Subscription) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InViewportUtils;
    (function (InViewportUtils) {
        /**
         * @param {?} value
         * @return {?}
         */
        function isObject(value) {
            const /** @type {?} */ type = typeof value;
            return value != null && (type == 'object' || type == 'function');
        }
        InViewportUtils.isObject = isObject;
        /**
         * @param {?} value
         * @return {?}
         */
        function isObjectLiteral(value) {
            return Object.prototype.toString.call(value) === '[object Object]';
        }
        InViewportUtils.isObjectLiteral = isObjectLiteral;
    })(InViewportUtils || (InViewportUtils = {}));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var isObjectLiteral = InViewportUtils.isObjectLiteral;
    /** @enum {number} */
    const InViewportConfigDirection = {
        Both: 0,
        Vertical: 1,
        Horizontal: 2,
    };
    InViewportConfigDirection[InViewportConfigDirection.Both] = "Both";
    InViewportConfigDirection[InViewportConfigDirection.Vertical] = "Vertical";
    InViewportConfigDirection[InViewportConfigDirection.Horizontal] = "Horizontal";
    class InViewportConfig {
        /**
         * @param {?=} options
         */
        constructor(options) {
            const /** @type {?} */ exist = isObjectLiteral(options);
            this.rootElement = exist && options.hasOwnProperty('rootElement') ? options.rootElement : void 0;
            this.partial = exist && options.hasOwnProperty('partial') ? options.partial : true;
            this.direction = exist && options.hasOwnProperty('direction') ? options.direction : void 0;
        }
        /**
         * @return {?}
         */
        get rootElement() {
            return this._rootElement;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        set rootElement(value) {
            this._rootElement = value && value.nodeType === 1 ? value : void 0;
        }
        /**
         * @return {?}
         */
        get partial() {
            return this._partial;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        set partial(value) {
            this._partial = !!value;
        }
        /**
         * @return {?}
         */
        get direction() {
            return this._direction;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        set direction(value) {
            const /** @type {?} */ availableOptions = [
                InViewportConfigDirection.Both,
                InViewportConfigDirection.Vertical,
                InViewportConfigDirection.Horizontal
            ];
            this._direction = availableOptions.indexOf(value) >= 0 ? value : InViewportConfigDirection.Both;
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    class InViewportService {
        /**
         * @param {?} ngZone
         */
        constructor(ngZone) {
            this.ngZone = ngZone;
            this.registry = [];
            this.trigger$ = new Subject.Subject();
        }
        /**
         * @param {?} target
         * @param {?=} rootElement
         * @return {?}
         */
        addTarget(target, rootElement) {
            this.ngZone.runOutsideAngular(() => this.register(target, rootElement));
        }
        /**
         * @param {?} target
         * @param {?=} rootElement
         * @return {?}
         */
        removeTarget(target, rootElement) {
            this.ngZone.runOutsideAngular(() => this.unregister(target, rootElement));
        }
        /**
         * @param {?} element
         * @return {?}
         */
        getRootElement(element) {
            return element && element.nodeType === 1 ? element : null;
        }
        /**
         * @param {?} rootElement
         * @return {?}
         */
        findRegistryEntry(rootElement) {
            return this.registry.find((item) => item.rootElement === this.getRootElement(rootElement));
        }
        /**
         * @param {?} entries
         * @return {?}
         */
        onChanges(entries) {
            if (Array.isArray(entries) && entries.length) {
                entries.forEach((entry) => this.trigger$.next(entry));
            }
        }
        /**
         * @param {?} target
         * @param {?=} rootElement
         * @return {?}
         */
        register(target, rootElement) {
            let /** @type {?} */ registryEntry = this.findRegistryEntry(rootElement);
            if (!registryEntry) {
                const /** @type {?} */ registryEntryObserverOptions = {
                    root: this.getRootElement(rootElement),
                    threshold: Array(101)
                        .fill(void 0)
                        .map((item, i) => i / 100)
                };
                registryEntry = {
                    targets: [target],
                    rootElement: this.getRootElement(rootElement),
                    observer: new IntersectionObserver((entries) => this.ngZone.run(() => this.onChanges(entries)), registryEntryObserverOptions)
                };
                registryEntry.observer.observe(target);
                this.registry.push(registryEntry);
            }
            else if (registryEntry.targets.indexOf(target) < 0) {
                registryEntry.targets.push(target);
                registryEntry.observer.observe(target);
            }
        }
        /**
         * @param {?} target
         * @param {?=} rootElement
         * @return {?}
         */
        unregister(target, rootElement) {
            const /** @type {?} */ registryEntry = this.findRegistryEntry(rootElement);
            const /** @type {?} */ registryEntryIdx = this.registry.indexOf(registryEntry);
            if (registryEntry) {
                const /** @type {?} */ targetIdx = registryEntry.targets.indexOf(target);
                if (targetIdx >= 0) {
                    registryEntry.observer.unobserve(target);
                    registryEntry.targets.splice(targetIdx, 1);
                }
                if (registryEntry.targets.length === 0) {
                    registryEntry.observer.disconnect();
                    this.registry.splice(registryEntryIdx, 1);
                }
            }
        }
    }
    InViewportService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    InViewportService.ctorParameters = () => [
        { type: core.NgZone, },
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var isObjectLiteral$1 = InViewportUtils.isObjectLiteral;
    const /** @type {?} */ InViewportMetadata = Symbol('InViewportMetadata');
    class InViewportDirective {
        /**
         * @param {?} platformId
         * @param {?} elementRef
         * @param {?} inViewportService
         */
        constructor(platformId, elementRef, inViewportService) {
            this.platformId = platformId;
            this.elementRef = elementRef;
            this.inViewportService = inViewportService;
            this.subscription = new Subscription.Subscription();
            this.config = new InViewportConfig();
            this.action$ = new core.EventEmitter();
        }
        /**
         * @param {?} value
         * @return {?}
         */
        set updateConfig(value) {
            if (isObjectLiteral$1(value)) {
                if (value.hasOwnProperty('rootElement')) {
                    this.config.rootElement = value.rootElement;
                }
                if (value.hasOwnProperty('partial')) {
                    this.config.partial = value.partial;
                }
                if (value.hasOwnProperty('direction')) {
                    this.config.direction = value.direction;
                }
            }
        }
        /**
         * @return {?}
         */
        ngAfterViewInit() {
            if (common.isPlatformBrowser(this.platformId)) {
                this.subscription.add(this.inViewportService.trigger$.subscribe((entry) => this.check(entry)));
                this.inViewportService.addTarget(this.elementRef.nativeElement, this.config.rootElement);
            }
            else {
                this.check(undefined, true);
            }
        }
        /**
         * @return {?}
         */
        ngOnDestroy() {
            this.subscription.unsubscribe();
            if (common.isPlatformBrowser(this.platformId)) {
                this.inViewportService.removeTarget(this.elementRef.nativeElement, this.config.rootElement);
            }
        }
        /**
         * @param {?} entry
         * @param {?=} force
         * @return {?}
         */
        check(entry, force) {
            if (force || (entry && entry.target === this.elementRef.nativeElement)) {
                const /** @type {?} */ value = force || (this.config.partial ? entry.intersectionRatio > 0 : entry.intersectionRatio === 1);
                this.action$.emit({
                    [InViewportMetadata]: { entry },
                    target: this.elementRef.nativeElement,
                    value
                });
            }
        }
    }
    InViewportDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[inViewport], [in-viewport]'
                },] },
    ];
    /** @nocollapse */
    InViewportDirective.ctorParameters = () => [
        { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] },] },
        { type: core.ElementRef, },
        { type: InViewportService, },
    ];
    InViewportDirective.propDecorators = {
        "action$": [{ type: core.Output, args: ['inViewportAction',] },],
        "updateConfig": [{ type: core.Input, args: ['inViewportOptions',] },],
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    class InViewportModule {
        /**
         * @return {?}
         */
        static forRoot() {
            return {
                ngModule: InViewportModule,
                providers: [InViewportService]
            };
        }
    }
    InViewportModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [],
                    declarations: [InViewportDirective],
                    exports: [InViewportDirective]
                },] },
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.InViewportModule = InViewportModule;
    exports.InViewportService = InViewportService;
    exports.InViewportConfig = InViewportConfig;
    exports.InViewportMetadata = InViewportMetadata;
    exports.InViewportConfigDirection = InViewportConfigDirection;
    exports.InViewportDirective = InViewportDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
